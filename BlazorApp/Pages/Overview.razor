@page "/"
@page "/overview"
@using ChartJs.Blazor.LineChart
@using ChartJs.Blazor.PieChart
@using BlazorApp.Data
@inject Test dataList;
@* @inject QueueTest managerList; *@

@* Font *@
<link href='https://fonts.googleapis.com/css?family=Roboto Slab' rel='stylesheet'>

@if (managers == null || managers.Count == 0)
{
    <p>Loading ....</p>
}
else{
    <div class="overview_container">
        <div class="summary_container">
            @* Summary text + runtime *@
            <div class="summary_caption_container" style="text-align: center;">Summary</div>
        
            @* Current running manager info *@
            <div class="Current_manager_info_container">
                <div>Current manager: @CurrentManagerDetails("managerName")</div><br>
                <div>Manager Runtime: @CurrentManagerDetails("runtime")</div>
            </div>
        
            <div class="Current_manager_container">
                <div class="Current_manager_errors">Current manager errors: @CurrentManagerDetails("totalErrors")
                    <ul class="error-reconciliation-formatting">
                        <div class="circle background-red"></div><li>Fatal: @CurrentManagerDetails("FATAL")</li>
                        <div class="circle background-lightred"></div><li>Error: @CurrentManagerDetails("ERROR")</li>
                        <div class="circle background-yellow"></div><li>Warning: @CurrentManagerDetails("WARNING")</li>
                        <div class="circle background-green"></div><li>Info: @CurrentManagerDetails("INFO")</li>
                    </ul>
                </div>
                <div class="Current_manager_reconciliations">Current manager reconciliations: @CurrentManagerDetails("totalRecons")
                    <ul class="error-reconciliation-formatting">
                        <div class="circle background-red"></div><li>Mismatch: @CurrentManagerDetails("MISMATCH")</li>
                        <div class="circle background-lightred"></div><li>Failed: @CurrentManagerDetails("FAILED")</li>
                        <div class="circle background-yellow"></div><li>Disabled: @CurrentManagerDetails("DISABLED")</li>
                        <div class="circle background-green"></div><li>OK: @CurrentManagerDetails("OK")</li>
                    </ul>
                </div>
            </div>
            <div class="mind-the-gap">&nbsp;</div>
        
            @* Manager queue *@
            <div class="manager-queue-container">
                <div class="queue-text">
                    <span class="queue-finished-text">Finished (TODO: CHANGE TO MANAGER COUNT): <b>@ManagerQueueCounterWriter("FINISHED")</b></span>
                    <span class="queue-inqueue-text">In queue (TODO: CHANGE TO FINISHED COUNT): <b>@ManagerQueueCounterWriter("QUEUED")</b></span>
                </div>
                <div class="manager-queue-circle">
                    @foreach(ManagerStatusHandler manager in managers)
                    {
                        <div class="manager-circle @ManagerCircleColour(manager)" @onmousemove="@((e) => GetHoveredManager(manager.Id, e, manager))">
                            @if (manager.Status == "RUNNING")
                            {
                                <img  src="Icons/current-manager-loader.svg" alt="loader" class="current-manager-loader">
                            }
                            @if(HoveredManager == manager.Id && HoveredManagerErrors != null)
                            {
                                <img src="Icons/triangle.svg" alt="triangle" class="hoverbox-arrow" style="position: absolute; left: @(MousePositionX + "px"); top: @(MousePositionY + "px"); transform: translate(-50%,-100%);">
                                <div class="hovered-manager" style="position: absolute; left: @(MousePositionX + "px"); top: @(MousePositionY + "px"); transform: translate(-50%,-13rem);">
                                    <div class="hoverbox-info">
                                        <div>Manager: @manager.Name</div>
                                        <div>Runtime: @CalculateRuntime(manager)</div>
                                        <div>Status: @manager.Status</div>
                                    </div>
                                    <div class="hoverbox-errors-recons">
                                        <div class="hoverbox-erros">
                                            <div>Errors</div>
                                            <ul class="error-reconciliation-formatting">
                                                <div class="circle background-red"></div><li>Fatal: @HoveredManagerErrors[0]</li>
                                                <div class="circle background-lightred"></div><li>Error: @HoveredManagerErrors[1]</li>
                                                <div class="circle background-yellow"></div><li>Warning: @HoveredManagerErrors[2]</li>
                                                <div class="circle background-green"></div><li>Info: @HoveredManagerErrors[3]</li>    
                                            </ul>
                                        </div>
                                        <div class="hoverbox-recons">
                                            <div>Reconciliations</div>
                                            <ul class="error-reconciliation-formatting">
                                                <div class="circle background-red"></div><li>Mismatch: @HoveredManagerRecons[0]</li>
                                                <div class="circle background-lightred"></div><li>Failed: @HoveredManagerRecons[1]</li>
                                                <div class="circle background-yellow"></div><li>Disabled: @HoveredManagerRecons[2]</li>
                                                <div class="circle background-green"></div><li>OK: @HoveredManagerRecons[3]</li>    
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>
                    }
                </div>
            </div>
            
            @* Total manager info *@
            <div class="Total_errors_and_reconciliations_container">
                <div class="info_total_errors">
                    Total Errors: @pieconfig_dataset_errors.Sum()
                    <ul class="error-reconciliation-formatting">
                        <div class="circle background-red"></div><li>Fatal: @pieconfig_dataset_errors[0]</li>
                        <div class="circle background-lightred"></div><li>Error: @pieconfig_dataset_errors[1]</li>
                        <div class="circle background-yellow"></div><li>Warning: @pieconfig_dataset_errors[2]</li>
                        <div class="circle background-green"></div><li>Info: @pieconfig_dataset_errors[3]</li>
                    </ul>
                </div>
                <div class="PieConfigTotalErrors">
                    <Chart Config="_pieconfig_errors" Height="50" Width="50"></Chart>
                </div>

                <div class="info_total_reconciliations">
                    Total Reconciliations: @pieconfig_dataset_reconciliations.Sum()
                    <ul class="error-reconciliation-formatting">
                        <div class="circle background-red"></div><li>Mismatch: @pieconfig_dataset_reconciliations[0]</li>
                        <div class="circle background-lightred"></div><li>Failed: @pieconfig_dataset_reconciliations[1]</li>
                        <div class="circle background-yellow"></div><li>Disabled: @pieconfig_dataset_reconciliations[2]</li>
                        <div class="circle background-green"></div><li>OK: @pieconfig_dataset_reconciliations[3]</li>
                    </ul>
                </div>
                <div class="pieConfigTotalReconciliations">
                    <Chart Config="_pieconfig_reconciliations" Height="50" Width="50"></Chart>
                </div>
            </div>

            @* Efficiency score table summary *@
            <div class="efficiency-container">
                <div class="efficiency-text">Median efficiency score: <b>2702</b></div><br/>
                <div class="efficiency-text">Total read: <b>17021044</b></div><br/>
                <div class="efficiency-text">Total written: <b>30461662</b></div>
            </div>
        </div>

        <div class="Overview-right">
            <div class="cpu_usage">
                <div class="chart-header">
                    <div class="dropdown">
                        <b class="selected-manager-name" title="">@(SelectedManager + "-" + managers[SelectedManager].Name)</b>
                        <img src="Icons/dropdown-arrow.svg" alt="dropdown-arrow" class="dropdown-arrow"/>
                        <img src="Icons/dropup-arrow.svg" alt="dropup-arrow" class="dropup-arrow"/>
                        <div class="dropdown-content">
                            @for (int i = 0, j = 0; i < managers.Count; i++) //id does not do anything as of right now, but might be useful later on
                            {
                                int managerID = i;
                                if (i == SelectedManager)
                                {
                                    continue;
                                }
                                else if (j == 0)
                                {
                                    j++;
                                    <div class="dropdown-content-first" title="@managers[managerID].Name" id="@managerID" @onclick="@(() => GetSelectedManagerID(managerID))">@(managerID + "-" + managers[managerID].Name)</div>
                                    continue;
                                }
                                <div title="@managers[managerID].Name" id="@managerID" @onclick="@(() => GetSelectedManagerID(managerID))">@(managerID + "-" + managers[managerID].Name)</div>
                            }
                        </div>
                    </div>
                    <div class="chart-title">
                        Memory/CPU
                    </div>
                </div>
                <div style="position: relative; width: 90%; left: 5%">
                    <Chart Config="_lineconfig"></Chart>
                </div>
                <div class="info-labels">
                    <div class="oblong background-lightred"></div>
                    <div class="cpu_text">CPU</div>
                    <div class="oblong background-green"></div>
                    <div class="memory_text">Memory</div>
                </div>
            </div>
            <div class="efficiency">

            </div>
        </div>
    </div>
}

@code{
    private LineConfig _lineconfig;
    LineDataset<int> lineconfig_dataset_cpu;
    LineDataset<int> lineconfig_dataset_memory;

    private PieConfig _pieconfig_errors;
    private PieConfig _pieconfig_reconciliations;
    PieDataset<int> pieconfig_dataset_errors;
    PieDataset<int> pieconfig_dataset_reconciliations;

    List<HealthDataTest> healthdatatests = new List<HealthDataTest>();
    
    //List<HealthData> _healthDatas = new List<HealthData>();
    
    //CAHNGED
    List<ManagerStatusHandler> managers;

    //List<ManagerStatusHandler> _finishedManagersList = new();
    List<LogData> _errorDataStorageList;
    List<LogData> _ReconDataStorageList;

    protected override async Task OnInitializedAsync()
    {
        ConfigureLineConfig();
        ConfigurePieConfig();
        //healthdatatests = await Task.Run(() => dataList.DataList());
        //managers = await Task.Run(() => managerList.ManagerList());
        string[] separtors = new string[] {" "};
        
    //Takes data from test and stores in list
        foreach (var data in healthdatatests)
        {
            if (data._ReportType == "CPU")
            {
                lineconfig_dataset_cpu.Add(data._NumericValue);
            }
            else if (data._ReportType == "MEMORY")
            {
                lineconfig_dataset_memory.Add(data._NumericValue);
            }
        }
        foreach (var party in healthdatatests)
        {
            if (party._ReportType == "CPU")
            {
                _lineconfig.Data.Labels.Add((party._Date.ToString().Split(separtors, 2, StringSplitOptions.RemoveEmptyEntries))[1]);
            }
        }

        _lineconfig.Data.Datasets.Add(lineconfig_dataset_cpu);
        _lineconfig.Data.Datasets.Add(lineconfig_dataset_memory);

        // pieconfig_dataset_errors = new PieDataset<int>(TotalErrorsSeverityCounter(managers))
        // {
        //     BackgroundColor = new[] // Color for the pies 
        //     {
        //         ColorUtil.ColorHexString(255, 23, 0), //Fatal Error
        //         ColorUtil.ColorHexString(227, 95, 82), //Error
        //         ColorUtil.ColorHexString(221, 155, 43), //Warning
        //         ColorUtil.ColorHexString(92, 188, 169) //Info
        //     },
        //     BorderColor = ColorUtil.ColorHexString(0, 0, 0),
        //     BorderWidth = 0
        // };
        
        // await Task.Run(() =>
        //     pieconfig_dataset_errors = new PieDataset<int>(TotalErrorsSeverityCounter(managers))
        //     {
        //         BackgroundColor = new[] // Color for the pies 
        //         {
        //             ColorUtil.ColorHexString(255, 23, 0), //Fatal Error
        //             ColorUtil.ColorHexString(227, 95, 82), //Error
        //             ColorUtil.ColorHexString(221, 155, 43), //Warning
        //             ColorUtil.ColorHexString(92, 188, 169) //Info
        //         },
        //         BorderColor = ColorUtil.ColorHexString(0, 0, 0),
        //         BorderWidth = 0
        //     });


        // _pieconfig_errors.Data.Datasets.Add(pieconfig_dataset_errors);
        //
        // pieconfig_dataset_reconciliations = new PieDataset<int>(TotalReconTypeCounter(managers))
        // {
        //     BackgroundColor = new[] // Color for the pies
        //     {
        //         ColorUtil.ColorHexString(255, 23, 0), //Mismatch
        //         ColorUtil.ColorHexString(227, 95, 82), //Failed
        //         ColorUtil.ColorHexString(221, 155, 43), //Disabled
        //         ColorUtil.ColorHexString(92, 188, 169) //OK
        //     },
        //     BorderColor = ColorUtil.ColorHexString(0, 0, 0),
        //     BorderWidth = 0,
        // };
        
        // _pieconfig_reconciliations.Data.Datasets.Add(pieconfig_dataset_reconciliations);
        
        // IMPLEMENTING DATA
        _errorDataStorageList = await Task.Run(() => ConversionDataAssigner.GetErrorLogList("error"));
        _ReconDataStorageList = await Task.Run(() => ConversionDataAssigner.GetErrorLogList("reconciliations"));
        managers = await Task.Run(() => ConversionDataAssigner.FinishedManagers);
        StateHasChanged();
        
        ReconUpdateTriggered += async (o, args) =>
        {
            _ReconDataStorageList.AddRange(args.ReconDataList);
            await InvokeAsync(StateHasChanged);
        };
        
        ErrorUpdateTriggered += async (o, args) =>
        {
            _errorDataStorageList.AddRange(args.LogDataList);
            await InvokeAsync(StateHasChanged);
        };

        UpdateOverviewTriggered += async (o, args) =>
        {
            pieconfig_dataset_errors = new PieDataset<int>(TotalErrorsSeverityCounter(managers))
            {
                BackgroundColor = new[] // Color for the pies 
                {
                    ColorUtil.ColorHexString(255, 23, 0), //Fatal Error
                    ColorUtil.ColorHexString(227, 95, 82), //Error
                    ColorUtil.ColorHexString(221, 155, 43), //Warning
                    ColorUtil.ColorHexString(92, 188, 169) //Info
                },
                BorderColor = ColorUtil.ColorHexString(0, 0, 0),
                BorderWidth = 0
            };
            // _pieconfig_errors.Data.Datasets.Add(pieconfig_dataset_errors);

            pieconfig_dataset_reconciliations = new PieDataset<int>(TotalReconTypeCounter(managers))
            {
                BackgroundColor = new[] // Color for the pies
                {
                    ColorUtil.ColorHexString(255, 23, 0), //Mismatch
                    ColorUtil.ColorHexString(227, 95, 82), //Failed
                    ColorUtil.ColorHexString(221, 155, 43), //Disabled
                    ColorUtil.ColorHexString(92, 188, 169) //OK
                },
                BorderColor = ColorUtil.ColorHexString(0, 0, 0),
                BorderWidth = 0,
            };
             _pieconfig_reconciliations.Data.Datasets.Add(pieconfig_dataset_reconciliations);
            await InvokeAsync(StateHasChanged);
        };

    }

}


@code{
    private void ConfigureLineConfig()
    {
        _lineconfig = new LineConfig();
        _lineconfig.Options = new LineOptions
        {
            Responsive = true,
            Title = new OptionsTitle
            {
                Display = false,
                Text = "Cpu & Memory usage",
                FontColor = "#FFFFFF"
            },
            Legend = new Legend
            {
                Position = Position.Bottom,
                Display = false,
            },
            Hover = new Hover
            {
                Mode = InteractionMode.Nearest,
                Intersect = true
            },
            Scales = new Scales
            {
                XAxes = new List<CartesianAxis> //scale for the x axes
                {
                    new CategoryAxis
                    {
                        ScaleLabel = new ScaleLabel
                        {
                            Display = true,
    //LabelString = "Time",
                            FontColor = "#FFFFFF",
                            FontSize = 15,
                        },
                        Ticks = new CategoryTicks
                        {
                            FontColor = "#FFFFFF",
                            FontSize = 13,
                        },
                        GridLines = new GridLines
                        {
                            Color = ColorUtil.ColorHexString(142, 142, 142),
                        }
                    },
                },
                YAxes = new List<CartesianAxis> // scale for the y axes
                {
                    new LinearCartesianAxis
                    {
                        ScaleLabel = new ScaleLabel
                        {
                            Display = true,
    //LabelString = "Usage %",
                            FontColor = "#FFFFFF",
                            FontSize = 15,

                        },
                        Ticks = new LinearCartesianTicks
                        {
                            FontSize = 13,
                            Padding = 10,
                            FontColor = "#FFFFFF", // Color for ticks, values on y axies
                            BeginAtZero = true,
                            StepSize = 10,
                            Max = 100,
                        },
                        GridLines = new GridLines
                        {
                            Color = ColorUtil.ColorHexString(142, 142, 142),
                            DrawBorder = false, // removes the border in the y axies

                        },
                    }
                }
            }
        };
        lineconfig_dataset_cpu = new LineDataset<int>
        {
            Label = "Cpu usage",
            BorderColor = ColorUtil.ColorHexString(227, 95, 82),
            BackgroundColor = ColorUtil.ColorString(0, 0, 0, 0.0),
            LineTension = 0,
        };

        lineconfig_dataset_memory = new LineDataset<int> // need data From healdata memeory class, Like the data above
        {
            Label = ("Memory usage"),
            BorderColor = ColorUtil.ColorString(92, 188, 169, 1),
            BackgroundColor = ColorUtil.ColorString(92, 188, 169, 0.3),
            LineTension = 0,
        };

    }

    private T SetUpPieLabels<T>(T config, string[] labels) where T : PieConfig
    {
        foreach (var label in labels)
        {
            config.Data.Labels.Add(label);
        }

        return config;
    }

}

@code{

    private void ConfigurePieConfig()
    {
        _pieconfig_errors = new PieConfig();
        _pieconfig_reconciliations = new PieConfig();

        _pieconfig_errors.Options = new PieOptions
        {
            Responsive = true,
            Title = new OptionsTitle
            {
                Display = false,
                Text = "Total Errors",
                FontColor = "#FFFFFF",
            },
            CutoutPercentage = 45,
            Legend = new Legend
            {
                Display = false,
            },
        };
        _pieconfig_reconciliations.Options = _pieconfig_errors.Options;

        _pieconfig_errors = SetUpPieLabels(_pieconfig_errors, new[] {"Fatal error", "Error", "Warning", "Info"});
        _pieconfig_reconciliations = SetUpPieLabels(_pieconfig_reconciliations, new[] {"Mismatch", "Failed", "Disabled", "OK"});
    }

}

@code
{
    int SelectedManager { get; set; }
    //int[] totalErrors = {0, 0, 0, 0};
    private void GetSelectedManagerID(int selectedID)
    {
        
        SelectedManager = selectedID;
    }
    
    // CHANGED
    private int[] ErrorSeverityCounter(List<LogData> errors)
	{
		int[] counter = {0, 0, 0, 0};

		foreach(LogData error in errors)
		{
		    Console.WriteLine(error.Grade + "********************************************************************************************************************************************");
			switch(error.Grade)
			{
				case "FATAL":
					counter[0]++;
				    break;

				case "ERROR":
					counter[1]++;
				break;

				case "WARN":
					counter[2]++;
				break;

				case "INFO":
				    counter[3]++;
				break;

				default:
					throw new ArgumentException($"{error.Grade} is not a valid argument");
			}
		}
        Console.WriteLine($"{counter[0]}, {counter[1]}, {counter[2]}, {counter[3]}");
	    return counter;
	}

    // CHANGED
    private int[] TotalErrorsSeverityCounter(List<ManagerStatusHandler> managers)
    {
        //_finishedManagersList[0].ErrorHandler.LogDataList[0].Grade
            int[] totalErrors = {0, 0, 0, 0};
            int[] counter = {0, 0, 0, 0};
        Console.WriteLine("WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW");
        foreach (var manager in managers)
        {
            counter = ErrorSeverityCounter(manager.ErrorHandler.LogDataList);
             for (int i = 0; i < 4; i++)
             {
                 totalErrors[i] += counter[i];
                 Console.WriteLine("TOTALERRORS "+ i + "= totalErrors[i]" + " ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ ");
             }
            
            // foreach (var error in manager.ErrorHandler.LogDataList)
            // {
            //     counter = ErrorSeverityCounter(error);
            //     for (int i = 0; i < 4; i++)
            //     {
            //         totalErrors[i] += counter[i];
            //     }
            // }
        }
            
            // foreach (var party in managers)
            // {
            //     test = ErrorSeverityCounter(party._errors);
            //     for (int i = 0; i < 4; i++)
            //     {
            //         totalErrors[i] += test[i];
            //     }
            // }
            //Console.WriteLine(Total_Errors[0]);
        return totalErrors;
    }

    // CHANGED
    private int[] CurrentManagerErrorCounter(List<ManagerStatusHandler> managers)
    {
        int[] currentManagerError = {0,0,0,0};
        foreach (var manager in managers)
        {
            currentManagerError = ErrorSeverityCounter(manager.ErrorHandler.LogDataList);
        }
        return currentManagerError;
    }
    
    // CHANGED
    private int[] ReconTypeCounter(List<LogData> recons)
    {
        int[] counter = {0, 0, 0, 0};

        foreach(LogData recon in recons)
        {
            switch(recon.Grade)
            {
                case "MISMATCH":
                    counter[0]++;
                    break;

                case "FAILED":
                    counter[1]++;
                    break;

                case "DISABLED":
                    counter[2]++;
                    break;

                case "OK":
                    counter[3]++;
                    break;

                default:
                    throw new ArgumentException($"{recon} is not a valid argument");
            }
        }

        return counter;
    }

    private int[] TotalReconTypeCounter(List<ManagerStatusHandler> managers)
    {

        int[] totalRecons = {0, 0, 0, 0};
        int[] counter = {0, 0, 0, 0};

        foreach (var manager in managers)
        {
            counter = ReconTypeCounter(manager.ReconciliationHandler.LogDataList);
            for (int i = 0; i < 4; i++)
            {
                totalRecons[i] += counter[i];
            }
        }
        return totalRecons;
    }


    private string ManagerCircleColour(ManagerStatusHandler manager)
	{
		int[] errors = ErrorSeverityCounter(manager.ErrorHandler.LogDataList);
        int[] recons = ReconTypeCounter(manager.ReconciliationHandler.LogDataList);
        
        ManagerQueueCounterFixer();

        switch (manager.Status)
        {
            // "FINISHED" -> "OK"
            case "OK":
               ManagerQueueCounter[0]++;
               if(errors[0] > 0 || recons[0] > 0){
                   return "background-red";
               }
               else if(errors[1] > 0 || recons[1] > 0){
                   return "background-lightred";
               }
               else if(errors[2] > 0 || recons[2] > 0){
                   return "background-yellow";
               }
               else return "background-green";
               
            case "RUNNING":
                CurrentManager = manager;
                return "background-running";
            
            case "QUEUED":
                ManagerQueueCounter[1]++;
                return "background-queued";
            default:
                throw new ArgumentException($"{manager.Status} is not a valid manager status");
        }
		
	}
  	
	int HoveredManager {get; set;}
    int[] HoveredManagerErrors { get; set; }
    int[] HoveredManagerRecons { get; set; }
    double MousePositionX { get; set; }
    double MousePositionY { get; set; }
    //CHANGED
    ManagerStatusHandler CurrentManager { get; set; }
    int[] ManagerQueueCounter { get; set; }
    
    
	private void GetHoveredManager(int hovered, MouseEventArgs e, ManagerStatusHandler manager)
	{
		HoveredManager = hovered;
	    MousePositionX = e.ClientX;
	    MousePositionY = e.ClientY;
	    HoveredManagerErrors = ErrorSeverityCounter(manager.ErrorHandler.LogDataList);
	    HoveredManagerRecons = ReconTypeCounter(manager.ReconciliationHandler.LogDataList);
	}

    private void ManagerQueueCounterFixer()
    {
        int total = 0;
        if (ManagerQueueCounter == null)
        {
            ManagerQueueCounter = new[] {0, 0};
        }
        for (int i = 0; i < 2; i++)
        {
            total += ManagerQueueCounter[i];
        }
        if (total == managers.Count - 1)
        {
            ManagerQueueCounter = new[] {0, 0};
        }
    }

    private int ManagerQueueCounterWriter(string status)
    {
        if (ManagerQueueCounter == null)
        {
            ManagerQueueCounterFixer();
        }
        if (status == "FINISHED")
        {
            return ManagerQueueCounter[0];
        }
        else if (status == "QUEUED")
        {
            return ManagerQueueCounter[1];
        }
        else
        {
            throw new ArgumentException($"{status} is not a valid argument");
        }
    }

    private string CalculateRuntime(ManagerStatusHandler manager)
    {
        string seconds = (manager.RunTime / 1000 % 60).ToString();
        
        string minutes = (((manager.RunTime / 1000) / 60) % 60).ToString();
        
        string hours = ((manager.RunTime / 1000) / 3600).ToString();

        if (seconds.Length < 2)
        {
            seconds = "0" + seconds;
        }
        if (minutes.Length < 2)
        {
            minutes = "0" + minutes;
        }
        if (hours.Length < 2)
        {
            hours = "0" + hours;
        }
        
        return hours + ':' + minutes + ':' + seconds;
    }
    
    //CHANGED
    private string CurrentManagerDetails(string wantedInfo)
    {
        if (CurrentManager == null)
        {
            return "0";
        }
        switch (wantedInfo)
        {
            case "managerName":
                return CurrentManager.Name;
            case "runtime":
                return CalculateRuntime(CurrentManager); 
            case "totalErrors":
                return CurrentManager.ErrorHandler.LogDataList.Count.ToString();
            case "FATAL":
                return ErrorSeverityCounter(CurrentManager.ErrorHandler.LogDataList)[0].ToString();
            case "ERROR":
                return ErrorSeverityCounter(CurrentManager.ErrorHandler.LogDataList)[1].ToString();
            case "WARNING":
                return ErrorSeverityCounter(CurrentManager.ErrorHandler.LogDataList)[2].ToString();
            case "INFO":
                return ErrorSeverityCounter(CurrentManager.ErrorHandler.LogDataList)[3].ToString();
            case "totalRecons":
                return CurrentManager.ReconciliationHandler.LogDataList.Count.ToString();
            case "MISMATCH":
                return ReconTypeCounter(CurrentManager.ReconciliationHandler.LogDataList)[0].ToString();
            case "FAILED":
                return ReconTypeCounter(CurrentManager.ReconciliationHandler.LogDataList)[1].ToString();
            case "DISABLED":
                return ReconTypeCounter(CurrentManager.ReconciliationHandler.LogDataList)[2].ToString();
            case "OK":
                return ReconTypeCounter(CurrentManager.ReconciliationHandler.LogDataList)[3].ToString();
            default:
                throw new ArgumentException($"{wantedInfo} is not a valid argument");
        }
    }
    
    private int[] CurrentManagerReconCounter(List<ManagerStatusHandler> managers)
    {
        int[] currentManagerRecons = {0,0,0,0};
        foreach (var manager in managers)
        {
            currentManagerRecons = ReconTypeCounter(manager.ReconciliationHandler.LogDataList);
        }
        return currentManagerRecons;
    }


}


